/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  7+                                   |
|   \\  /    A nd           | Web:      www.openfoam.org                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/

FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    location    "constant";
    object      fvModels;

}

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

// INJECTION WELL 1
SbSource1
{
    type            coded;

    // selectionMode   all;

    selectionMode   cellSet;
    cellSet         box1;

    field           Sb;

    codeInclude
    #{
    #};

    codeAddSup
    #{
        // Pout<< "**codeAddSup**" << endl;
        // const Time& time = mesh().time();
        // const scalarField& V = mesh().V();
        // scalarField& heSource = eqn.source();
        // heSource -= 0.1*V; //*sqr(time.value())*V;

        // const Time& time = mesh().time();
        // const scalar currentTime = time.value();

        const scalarField& V = mesh().V();
        scalarField& SbSource = eqn.source();

        scalar qtValue = mesh().time().controlDict().lookupOrDefault<scalar>("qtValue", 1.0);
        // Info << qtValue << endl;

        // // =========== BOX1 SELECTION ========================
        // // ===================================================
        // Retrieve the cell set named "box1"
        cellSet selectedCells(mesh(), "box1");
        // Iterate over the cell set and apply the source term
        forAllConstIter(labelHashSet, selectedCells, iter)
        {
            label cellI = iter.key();
            // SwSource[cellI] -= (0.1) * V[cellI];
            
            // const scalar x = mesh().C()[cellI].component(0);
            // const scalar y = 0.5;

            // SwSource[cellI] -= ((x-pow(x,2))) * V[cellI];
            SbSource[cellI] -= qtValue;// * V[cellI]; 
        }



        // =========== ALL SELECTION ========================
        // ===================================================
        // forAll(SwSource, i)
        // {
        //     const scalar x = mesh().C()[i].component(0);
        //     const scalar y = 0.5;

        //     // SwSource[i] -= ((x-pow(x,2))*(y-pow(y,2)) + 
        //     //                 2.0*currentTime*(x-pow(x,2)+y-pow(y,2))) * V[i];

        //     SwSource[i] -= (x/4.0 - pow(x,2)/4.0 + 0.5*currentTime) * V[i];
        // };
 

    #};

    codeAddRhoSup
    #{
        Pout<< "**codeAddRhoSup**" << endl;
    #};

    codeAddAlphaRhoSup
    #{
        Pout<< "**codeAddAlphaRhoSup**" << endl;
    #};
}

pSource1
{
    type            coded;

    // selectionMode   all;

    selectionMode   cellSet;
    cellSet         box1;

    field           p;

    codeInclude
    #{
    #};

    codeAddSup
    #{
        // const Time& time = mesh().time();
        // const scalar currentTime = time.value();

        const scalarField& V = mesh().V();
        scalarField& pSource = eqn.source();

        scalar qtValue = mesh().time().controlDict().lookupOrDefault<scalar>("qtValue", 1.0);
        // Info << qtValue << endl;   
        
        // =========== BOX1 SELECTION ========================
        // ===================================================
        // Retrieve the cell set named "box1"
        cellSet selectedCells(mesh(), "box1");
        // Iterate over the cell set and apply the source term
        forAllConstIter(labelHashSet, selectedCells, iter)
        {
            label cellI = iter.key();
            // SwSource[cellI] -= (0.1) * V[cellI];
            
            // const scalar x = mesh().C()[cellI].component(0);
            // const scalar y = 0.5;

            // SwSource[cellI] -= ((x-pow(x,2))) * V[cellI];
            pSource[cellI] -= qtValue;// * V[cellI]; // 100m3/dia -> m3/10s
        }



        // =========== ALL SELECTION ========================
        // ===================================================
        // forAll(pSource, i)
        // {
        //     const scalar x = mesh().C()[i].component(0);
        //     const scalar y = 0.5;

        //     pSource[i] -= currentTime * V[i]; // 4.0*currentTime*(x-pow(x,2)+y-pow(y,2)) * V[i];
        // };
 

    #};

    codeAddRhoSup
    #{
        Pout<< "**codeAddRhoSup**" << endl;
    #};

    codeAddAlphaRhoSup
    #{
        Pout<< "**codeAddAlphaRhoSup**" << endl;
    #};
}

// INJECTION WELL 2
SbSource2
{
    type            coded;

    // selectionMode   all;

    selectionMode   cellSet;
    cellSet         box2;

    field           Sb;

    codeInclude
    #{
    #};

    codeAddSup
    #{
        // Pout<< "**codeAddSup**" << endl;
        // const Time& time = mesh().time();
        // const scalarField& V = mesh().V();
        // scalarField& heSource = eqn.source();
        // heSource -= 0.1*V; //*sqr(time.value())*V;

        // const Time& time = mesh().time();
        // const scalar currentTime = time.value();

        const scalarField& V = mesh().V();
        scalarField& SbSource = eqn.source();

        scalar qtValue = mesh().time().controlDict().lookupOrDefault<scalar>("qtValue", 1.0);
        // Info << qtValue << endl;

        // // =========== BOX1 SELECTION ========================
        // // ===================================================
        // Retrieve the cell set named "box1"
        cellSet selectedCells(mesh(), "box2");
        // Iterate over the cell set and apply the source term
        forAllConstIter(labelHashSet, selectedCells, iter)
        {
            label cellI = iter.key();
            // SwSource[cellI] -= (0.1) * V[cellI];
            
            // const scalar x = mesh().C()[cellI].component(0);
            // const scalar y = 0.5;

            // SwSource[cellI] -= ((x-pow(x,2))) * V[cellI];
            SbSource[cellI] -= qtValue;// * V[cellI]; 
        }



        // =========== ALL SELECTION ========================
        // ===================================================
        // forAll(SwSource, i)
        // {
        //     const scalar x = mesh().C()[i].component(0);
        //     const scalar y = 0.5;

        //     // SwSource[i] -= ((x-pow(x,2))*(y-pow(y,2)) + 
        //     //                 2.0*currentTime*(x-pow(x,2)+y-pow(y,2))) * V[i];

        //     SwSource[i] -= (x/4.0 - pow(x,2)/4.0 + 0.5*currentTime) * V[i];
        // };
 

    #};

    codeAddRhoSup
    #{
        Pout<< "**codeAddRhoSup**" << endl;
    #};

    codeAddAlphaRhoSup
    #{
        Pout<< "**codeAddAlphaRhoSup**" << endl;
    #};
}

pSource2
{
    type            coded;

    // selectionMode   all;

    selectionMode   cellSet;
    cellSet         box2;

    field           p;

    codeInclude
    #{
    #};

    codeAddSup
    #{
        // const Time& time = mesh().time();
        // const scalar currentTime = time.value();

        const scalarField& V = mesh().V();
        scalarField& pSource = eqn.source();

        scalar qtValue = mesh().time().controlDict().lookupOrDefault<scalar>("qtValue", 1.0);
        // Info << qtValue << endl;   
        
        // =========== BOX1 SELECTION ========================
        // ===================================================
        // Retrieve the cell set named "box1"
        cellSet selectedCells(mesh(), "box2");
        // Iterate over the cell set and apply the source term
        forAllConstIter(labelHashSet, selectedCells, iter)
        {
            label cellI = iter.key();
            // SwSource[cellI] -= (0.1) * V[cellI];
            
            // const scalar x = mesh().C()[cellI].component(0);
            // const scalar y = 0.5;

            // SwSource[cellI] -= ((x-pow(x,2))) * V[cellI];
            pSource[cellI] -= qtValue;// * V[cellI]; // 100m3/dia -> m3/10s
        }



        // =========== ALL SELECTION ========================
        // ===================================================
        // forAll(pSource, i)
        // {
        //     const scalar x = mesh().C()[i].component(0);
        //     const scalar y = 0.5;

        //     pSource[i] -= currentTime * V[i]; // 4.0*currentTime*(x-pow(x,2)+y-pow(y,2)) * V[i];
        // };
 

    #};

    codeAddRhoSup
    #{
        Pout<< "**codeAddRhoSup**" << endl;
    #};

    codeAddAlphaRhoSup
    #{
        Pout<< "**codeAddAlphaRhoSup**" << endl;
    #};
}

// INJECTION WELL 3
SbSource3
{
    type            coded;

    // selectionMode   all;

    selectionMode   cellSet;
    cellSet         box3;

    field           Sb;

    codeInclude
    #{
    #};

    codeAddSup
    #{
        // Pout<< "**codeAddSup**" << endl;
        // const Time& time = mesh().time();
        // const scalarField& V = mesh().V();
        // scalarField& heSource = eqn.source();
        // heSource -= 0.1*V; //*sqr(time.value())*V;

        // const Time& time = mesh().time();
        // const scalar currentTime = time.value();

        const scalarField& V = mesh().V();
        scalarField& SbSource = eqn.source();

        scalar qtValue = mesh().time().controlDict().lookupOrDefault<scalar>("qtValue", 1.0);
        // Info << qtValue << endl;

        // // =========== BOX1 SELECTION ========================
        // // ===================================================
        // Retrieve the cell set named "box1"
        cellSet selectedCells(mesh(), "box3");
        // Iterate over the cell set and apply the source term
        forAllConstIter(labelHashSet, selectedCells, iter)
        {
            label cellI = iter.key();
            // SwSource[cellI] -= (0.1) * V[cellI];
            
            // const scalar x = mesh().C()[cellI].component(0);
            // const scalar y = 0.5;

            // SwSource[cellI] -= ((x-pow(x,2))) * V[cellI];
            SbSource[cellI] -= qtValue;// * V[cellI]; 
        }



        // =========== ALL SELECTION ========================
        // ===================================================
        // forAll(SwSource, i)
        // {
        //     const scalar x = mesh().C()[i].component(0);
        //     const scalar y = 0.5;

        //     // SwSource[i] -= ((x-pow(x,2))*(y-pow(y,2)) + 
        //     //                 2.0*currentTime*(x-pow(x,2)+y-pow(y,2))) * V[i];

        //     SwSource[i] -= (x/4.0 - pow(x,2)/4.0 + 0.5*currentTime) * V[i];
        // };
 

    #};

    codeAddRhoSup
    #{
        Pout<< "**codeAddRhoSup**" << endl;
    #};

    codeAddAlphaRhoSup
    #{
        Pout<< "**codeAddAlphaRhoSup**" << endl;
    #};
}

pSource3
{
    type            coded;

    // selectionMode   all;

    selectionMode   cellSet;
    cellSet         box3;

    field           p;

    codeInclude
    #{
    #};

    codeAddSup
    #{
        // const Time& time = mesh().time();
        // const scalar currentTime = time.value();

        const scalarField& V = mesh().V();
        scalarField& pSource = eqn.source();

        scalar qtValue = mesh().time().controlDict().lookupOrDefault<scalar>("qtValue", 1.0);
        // Info << qtValue << endl;   
        
        // =========== BOX1 SELECTION ========================
        // ===================================================
        // Retrieve the cell set named "box1"
        cellSet selectedCells(mesh(), "box3");
        // Iterate over the cell set and apply the source term
        forAllConstIter(labelHashSet, selectedCells, iter)
        {
            label cellI = iter.key();
            // SwSource[cellI] -= (0.1) * V[cellI];
            
            // const scalar x = mesh().C()[cellI].component(0);
            // const scalar y = 0.5;

            // SwSource[cellI] -= ((x-pow(x,2))) * V[cellI];
            pSource[cellI] -= qtValue;// * V[cellI]; // 100m3/dia -> m3/10s
        }



        // =========== ALL SELECTION ========================
        // ===================================================
        // forAll(pSource, i)
        // {
        //     const scalar x = mesh().C()[i].component(0);
        //     const scalar y = 0.5;

        //     pSource[i] -= currentTime * V[i]; // 4.0*currentTime*(x-pow(x,2)+y-pow(y,2)) * V[i];
        // };
 

    #};

    codeAddRhoSup
    #{
        Pout<< "**codeAddRhoSup**" << endl;
    #};

    codeAddAlphaRhoSup
    #{
        Pout<< "**codeAddAlphaRhoSup**" << endl;
    #};
}

// INJECTION WELL 4
SbSource4
{
    type            coded;

    // selectionMode   all;

    selectionMode   cellSet;
    cellSet         box4;

    field           Sb;

    codeInclude
    #{
    #};

    codeAddSup
    #{
        // Pout<< "**codeAddSup**" << endl;
        // const Time& time = mesh().time();
        // const scalarField& V = mesh().V();
        // scalarField& heSource = eqn.source();
        // heSource -= 0.1*V; //*sqr(time.value())*V;

        // const Time& time = mesh().time();
        // const scalar currentTime = time.value();

        const scalarField& V = mesh().V();
        scalarField& SbSource = eqn.source();

        scalar qtValue = mesh().time().controlDict().lookupOrDefault<scalar>("qtValue", 1.0);
        // Info << qtValue << endl;

        // // =========== BOX1 SELECTION ========================
        // // ===================================================
        // Retrieve the cell set named "box1"
        cellSet selectedCells(mesh(), "box4");
        // Iterate over the cell set and apply the source term
        forAllConstIter(labelHashSet, selectedCells, iter)
        {
            label cellI = iter.key();
            // SwSource[cellI] -= (0.1) * V[cellI];
            
            // const scalar x = mesh().C()[cellI].component(0);
            // const scalar y = 0.5;

            // SwSource[cellI] -= ((x-pow(x,2))) * V[cellI];
            SbSource[cellI] -= qtValue;// * V[cellI]; 
        }



        // =========== ALL SELECTION ========================
        // ===================================================
        // forAll(SwSource, i)
        // {
        //     const scalar x = mesh().C()[i].component(0);
        //     const scalar y = 0.5;

        //     // SwSource[i] -= ((x-pow(x,2))*(y-pow(y,2)) + 
        //     //                 2.0*currentTime*(x-pow(x,2)+y-pow(y,2))) * V[i];

        //     SwSource[i] -= (x/4.0 - pow(x,2)/4.0 + 0.5*currentTime) * V[i];
        // };
 

    #};

    codeAddRhoSup
    #{
        Pout<< "**codeAddRhoSup**" << endl;
    #};

    codeAddAlphaRhoSup
    #{
        Pout<< "**codeAddAlphaRhoSup**" << endl;
    #};
}

pSource4
{
    type            coded;

    // selectionMode   all;

    selectionMode   cellSet;
    cellSet         box4;

    field           p;

    codeInclude
    #{
    #};

    codeAddSup
    #{
        // const Time& time = mesh().time();
        // const scalar currentTime = time.value();

        const scalarField& V = mesh().V();
        scalarField& pSource = eqn.source();

        scalar qtValue = mesh().time().controlDict().lookupOrDefault<scalar>("qtValue", 1.0);
        // Info << qtValue << endl;   
        
        // =========== BOX1 SELECTION ========================
        // ===================================================
        // Retrieve the cell set named "box1"
        cellSet selectedCells(mesh(), "box4");
        // Iterate over the cell set and apply the source term
        forAllConstIter(labelHashSet, selectedCells, iter)
        {
            label cellI = iter.key();
            // SwSource[cellI] -= (0.1) * V[cellI];
            
            // const scalar x = mesh().C()[cellI].component(0);
            // const scalar y = 0.5;

            // SwSource[cellI] -= ((x-pow(x,2))) * V[cellI];
            pSource[cellI] -= qtValue;// * V[cellI]; // 100m3/dia -> m3/10s
        }



        // =========== ALL SELECTION ========================
        // ===================================================
        // forAll(pSource, i)
        // {
        //     const scalar x = mesh().C()[i].component(0);
        //     const scalar y = 0.5;

        //     pSource[i] -= currentTime * V[i]; // 4.0*currentTime*(x-pow(x,2)+y-pow(y,2)) * V[i];
        // };
 

    #};

    codeAddRhoSup
    #{
        Pout<< "**codeAddRhoSup**" << endl;
    #};

    codeAddAlphaRhoSup
    #{
        Pout<< "**codeAddAlphaRhoSup**" << endl;
    #};
}

// PRODUCTION WELL 1
SbSource5
{
    type            coded;

    // selectionMode   all;

    selectionMode   cellSet;
    cellSet         box5;

    field           Sb;

    codeInclude
    #{
        #include <fstream>  // Standard C++ file handling
        #include <sys/stat.h> // For checking if file exists
        #include "IOstreams.H"
    #};

    codeAddSup
    #{
        // Pout<< "**codeAddSup**" << endl;
        // const Time& time = mesh().time();
        // const scalarField& V = mesh().V();
        // scalarField& heSource = eqn.source();
        // heSource -= 0.1*V; //*sqr(time.value())*V;

        const Time& time = mesh().time();
        const scalar currentTime = time.value();

        const scalarField& V = mesh().V();
        scalarField& SbSource = eqn.source();

        // Access Fb (assuming it is a volScalarField)
        const volScalarField& Fb = mesh().lookupObject<volScalarField>("Fb");
        const volScalarField& Fc = mesh().lookupObject<volScalarField>("Fc");

        const int nINJ_wells = 4;

        scalar qtValue = mesh().time().controlDict().lookupOrDefault<scalar>("qtValue", 1.0);
        // Info << qtValue << endl;

        // production file
        std::ofstream outFile("production.txt", std::ios::app);
        // outFile << "TimeStep,CellID,qw,qo\n"; 

        
        // // =========== BOX1 SELECTION ========================
        // // ===================================================
        // Retrieve the cell set named "box1"
        cellSet selectedCells(mesh(), "box5");
        // Iterate over the cell set and apply the source term
        forAllConstIter(labelHashSet, selectedCells, iter)
        {
            label cellI = iter.key();
            // SwSource[cellI] -= (0.1) * V[cellI];
            
            // const scalar x = mesh().C()[cellI].component(0);
            // const scalar y = 0.5;

            // SwSource[cellI] -= ((x-pow(x,2))) * V[cellI];
            
            
            
            // SbSource[cellI] += 0.5*1.0e-2 * V[cellI]; // 100m3/dia -> m3/10s


            

            scalar FbValue = Fb[cellI];
            scalar FcValue = Fc[cellI];
            SbSource[cellI] += FbValue * (nINJ_wells * qtValue);// * V[cellI];

            // Write the time step, cell ID, and Fb value to the file
            // Info << "TimeStep\tCellID\tFbValue\n";  // Write header with time step
            // Info << currentTime << "\t" << cellI << "\t" << FbValue << "\n";

            // Info << "TimeStep\tCellID\tFb*qt\tFc*qt\n";  // Write header with time step
            // Info << currentTime << "\t" << cellI << "\t" << FbValue*(nINJ_wells * qtValue) << "\t" << FcValue*(nINJ_wells * qtValue) << "\n";

            // writing file
            outFile << currentTime << "," << cellI << "," << FbValue*(nINJ_wells * qtValue) << "," << FcValue*(nINJ_wells * qtValue) << "\n";
            
        }

        outFile.close();



        // =========== ALL SELECTION ========================
        // ===================================================
        // forAll(SwSource, i)
        // {
        //     const scalar x = mesh().C()[i].component(0);
        //     const scalar y = 0.5;

        //     // SwSource[i] -= ((x-pow(x,2))*(y-pow(y,2)) + 
        //     //                 2.0*currentTime*(x-pow(x,2)+y-pow(y,2))) * V[i];

        //     SwSource[i] -= (x/4.0 - pow(x,2)/4.0 + 0.5*currentTime) * V[i];
        // };
 

    #};

    codeAddRhoSup
    #{
        Pout<< "**codeAddRhoSup**" << endl;
    #};

    codeAddAlphaRhoSup
    #{
        Pout<< "**codeAddAlphaRhoSup**" << endl;
    #};
}

pSource5
{
    type            coded;

    // selectionMode   all;

    selectionMode   cellSet;
    cellSet         box5;

    field           p;

    codeInclude
    #{
    #};

    codeAddSup
    #{
        // const Time& time = mesh().time();
        // const scalar currentTime = time.value();

        const scalarField& V = mesh().V();
        scalarField& pSource = eqn.source();

        const int nINJ_wells = 4;

        scalar qtValue = mesh().time().controlDict().lookupOrDefault<scalar>("qtValue", 1.0);
        // Info << qtValue << endl;
        
        // =========== BOX1 SELECTION ========================
        // ===================================================
        // Retrieve the cell set named "box1"
        cellSet selectedCells(mesh(), "box5");
        // Iterate over the cell set and apply the source term
        forAllConstIter(labelHashSet, selectedCells, iter)
        {
            label cellI = iter.key();
            // SwSource[cellI] -= (0.1) * V[cellI];
            
            // const scalar x = mesh().C()[cellI].component(0);
            // const scalar y = 0.5;

            // SwSource[cellI] -= ((x-pow(x,2))) * V[cellI];
            pSource[cellI] += (nINJ_wells * qtValue);// * V[cellI]; // 100m3/dia -> m3/10s
        }



        // =========== ALL SELECTION ========================
        // ===================================================
        // forAll(pSource, i)
        // {
        //     const scalar x = mesh().C()[i].component(0);
        //     const scalar y = 0.5;

        //     pSource[i] -= currentTime * V[i]; // 4.0*currentTime*(x-pow(x,2)+y-pow(y,2)) * V[i];
        // };
 

    #};

    codeAddRhoSup
    #{
        Pout<< "**codeAddRhoSup**" << endl;
    #};

    codeAddAlphaRhoSup
    #{
        Pout<< "**codeAddAlphaRhoSup**" << endl;
    #};
}

